Design Notes

Should this be a UInt package? Or something like BinaryArray instead.
- Not really intended for doing maths.
- Only mathmatical operations needed for target project
  are x == 0 or x > 0; Could simplify to IsZero and cut out
  a lot of noise.
- Need a "left to right" view rather than most / least significant
  view on the binary. ie, each bit is of equal significance.


Should I use a proxy to map bit access to chunked access?
- Main question is performance. Proxys are slow. Does
  this effect my use case, since the underlying data type
  doesn't actually have bit level array level access?
- For the target use case I'll probably be setting way
  more than one bit at a time, which will need to be done
  by functions anyway. Can provide array [] access and
  more efficient function getting setting as well?

Flex expansion:
- How should these grow and shrink?
  - When two mismatched size are used in a bitwise or comparison operation : Grow to match biggest
  - When an index larger than the current length is used to set: Grow to index or nearest byte?: Grow to index.
  - When an index larger than the current length is used to get: No action? Or Grow to index?: No action. Return undefined (like normal array)
  - Do shift operations cause expansios: Probs not, create growAndShiftLeft and growAndShiftRight(growBy, shiftBy)
- Should we provide a way of specifying the default padding value during expansion: No,leave this out. Zero is used.
  - 0 is default: yah
  - 1 setable: through a property or shoehorn it into the constructor?
- Add some functions to grow / shrink

// Fast vs Slow operations

If we know ahead of time that we are using
fixed size and fixed chunkSize Uints, we can 
do bitwise and comparison operations much more
quickly because we will be omitting size 
and chunkType checks and coalescing.

For instance, when we don't have this info,
we need to check:
- Same size
- Same chunk size
- If either don't match, we need to pad. Doing
  so increases cpu cycles and memory usage.

Notes on GROW mutability:

Flex:
mutFns
- All operands and the result will be mutated during GROW
  - Is this what we want? Or should it just be the result?
    - If we mutate all to be the same size: 
- OR: Only result is mutated.
  - All accesses to index > length just return 0 for purpose
    of calculation.
imuFns
- No operands will be mutated during GROW
  - This means if there is a mismatch, new X and new Y will occur for every run
  - Probs slow as balls 

Decision to be made with flex:
- Do we impose default behaviour for mismatched lengths
- Or do we make the user specify what they want to happen

a = new FlexBinaryArray(40);
b = new FlexBinaryArray(8);
c = new FlexBinaryArray(126);

fns.andMany(a, b, c); // Treat them all as 126 with right most bits padded to Zero

fns.matchSize(
  largest | smallest,
  left | right,
  0 | 1,
  a, b, c);

fns.matchSize(largest, left, 0, a, b, c)
fns.matchSize(largest, left, 0, ...ops)

// aliases
fns.growLeft(fillBit: 0 | 1, ...ops)
fns.growRight(fillBit: 0 | 1, ...ops)
fns.shrinkLeft(...ops)
fns.shrinkRight(...ops)

// mut / imu
mut: all operands mutated
imu: return ...ops.length x new objects

// resize (vs match)
- Resize grows by specific number instead of matching another operand
- Same deal with align and fillBit

Fixed don't need Align, Flex does? Or should there be functions
to transform Fixed of different sizes? Suppose it would make sense.
Typing of returned values would be tricky I think.

I think typing wise you would need to specify the length
for fixed ones, even if the underlying sizes were different.

Fixed transforms should not have mutable versions otherwise
you can shoot yourself in the foot (don't think there's a static
way of handling the following)

const fns = getFixedFns(32, 32)
const a = fns.create();
const b = fns.create();

const aResized = fns.mut(64, "left", 1, a);
// a has now been physically altered, but will
// the type system pick that up if we try use "a"
// again:

fns.and(a, b); // Should fail because a is no longer <32,32>
// I don't think this will fail though.

fns.and(aResized, b) // Can and should fail (will get caught)

const fns = getFixedFns(64, 32);
fns.and(a, a); // Should work

So I think fixed transformers will need to be explicit
that they are copying the original into a new sized item.
copyToNewSize(newLen, newChunk, align, fill, operand);

// Maybe we do resize functions with left-to-right Zero
// fills and build additional helpers on top of that
// resize(len, chun, op) copyToNewSize(len, chun, op)
// User would be responsible for shifting, filling, etc

// growLeft(size, fillBit)
    -> shiftLeft(oldSize - newSize)
    -> setBits(oldsize, newsize, fillBit)